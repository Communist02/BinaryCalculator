// generated by Fast Light User Interface Designer (fluid) version 1.0400

#include "binary_calculator.h"
#include <string>
#include <bitset>
#include <sstream>
Fl_Button* ab[32];
Fl_Button* bb[32];
Fl_Button* cb[32];
int32_t a = 0;
int32_t b = 0;
int32_t c = 0;

static long long pow(int32_t exponent) {
  return (long long)1 << exponent;
}

static std::string intToDec(int32_t number) {
  return std::to_string(number);
}

static std::string intToBin(int32_t number) {
  if (number == 0) {
    return "0";
  }
  std::string str = std::bitset<32>(number).to_string().c_str();
  size_t firstOnePos = str.find('1');
  if (firstOnePos == std::string::npos) {
    return "0";
  }
  return str.substr(firstOnePos);
}

static std::string intToBinPlus(int32_t number) {
  return std::bitset<32>(number).to_string();
}

static std::string intToHex(int32_t number) {
  std::stringstream ss;
  ss << std::hex << number;
  return ss.str();
}

static std::string intToOct(int32_t number) {
  std::stringstream ss;
  ss << std::oct << number;
  return ss.str();
}

static std::string intToQuat(uint32_t number) {
  std::string quaternaryString;
  do {
    int32_t remainder = number % 4;
    char digit = '0' + remainder;
    quaternaryString = digit + quaternaryString;
    number /= 4;

  } while (number > 0);

  return quaternaryString;
}

static int32_t hexToInt(const char* hex) {
  int32_t num = 0, base = 1;
      int32_t len = strlen(hex);
      for (int i = len - 1; i >= 0; i--) {
          if (hex[i] >= '0' && hex[i] <= '9') {
              num += (hex[i] - '0') * base;
          } else if (hex[i] >= 'A' && hex[i] <= 'F') {
              num += (hex[i] - 'A' + 10) * base;
          } else if (hex[i] >= 'a' && hex[i] <= 'f') {
              num += (hex[i] - 'a' + 10) * base;
          }
          base *= 16;
      }
      return num;
}

static int32_t octToInt(const char* oct) {
  int32_t num = 0;
  int32_t base = 1;
  int len = strlen(oct);
  for (int i = len - 1; i >= 0; i--) {
    int32_t digit = oct[i] - '0';
    num += digit * base;
    base *= 8;
  }
  return num;
}

static int32_t quatToInt(const char* quat) {
  int32_t num = 0;
  int32_t base = 1;
  int len = strlen(quat);
  for (int i = len - 1; i >= 0; i--) {
    int32_t digit = quat[i] - '0';
    num += digit * base;
    base *= 4;
  }
  return num;
}

static int32_t binToInt(const char* bin) {
  std::string str = bin;
  int32_t result = 0;
  int32_t power = 0;
  for (int i = str.length() - 1; i >= 0; i--) {
    if (bin[i] == '1') {
      result += pow(power);
    }
    power++;
  }
  return result;
}

static void cb_button(Fl_Button* widget, void* data) {
  if (widget->label() == "0") {
    widget->label("1");
  } else {
    widget->label("0");
  }

  a = 0;
  b = 0;
  c = 0;

  for (int i = 0; i < 32; i++) {
    if (ab[i]->label() == "1") {
      a += pow(31 - i); // Прибавить степень двойки
    }
    if (bb[i]->label() == "1") {
      b += pow(31 - i); // Прибавить степень двойки
    }
    if (cb[i]->label() == "1") {
      c += pow(31 - i); // Прибавить степень двойки
    }
  }

  if (n->value() == 10) {
    outputA->value(intToDec(a % pow(bits->value())).c_str());
    outputB->value(intToDec(b % pow(bits->value())).c_str());
    outputC->value(intToDec(c % pow(bits->value())).c_str());
  } else if (n->value() == 2) {
    outputA->value(intToBin(a % pow(bits->value())).c_str());
    outputB->value(intToBin(b % pow(bits->value())).c_str());
    outputC->value(intToBin(c % pow(bits->value())).c_str());
  } else if (n->value() == 16) {
    outputA->value(intToHex(a % pow(bits->value())).c_str());
    outputB->value(intToHex(b % pow(bits->value())).c_str());
    outputC->value(intToHex(c % pow(bits->value())).c_str());
  } else if (n->value() == 8) {
    outputA->value(intToOct(a % pow(bits->value())).c_str());
    outputB->value(intToOct(b % pow(bits->value())).c_str());
    outputC->value(intToOct(c % pow(bits->value())).c_str());
  } else if (n->value() == 4) {
    outputA->value(intToQuat(a % pow(bits->value())).c_str());
    outputB->value(intToQuat(b % pow(bits->value())).c_str());
    outputC->value(intToQuat(c % pow(bits->value())).c_str());
  }
}

static void resultOutput() {
  if (n->value() == 2) {
    outputC->value(intToBin(c % pow(bits->value())).c_str());
  } else if (n->value() == 10) {
    outputC->value(intToDec(c % pow(bits->value())).c_str());
  } else if (n->value() == 16) {
    outputC->value(intToHex(c % pow(bits->value())).c_str());
  } else if (n->value() == 8) {
    outputC->value(intToOct(c % pow(bits->value())).c_str());
  } else if (n->value() == 4) {
    outputC->value(intToQuat(c % pow(bits->value())).c_str());
  }

  std::string str = intToBinPlus(c);

  for (int i = 0; i < 32; i++) {
    if (str[i] == '1') {
      cb[i]->label("1");
    } else {
      cb[i]->label("0");
    }
  }
}

static void updateA() {
  std::string strA = intToBinPlus(a);

  for (int i = 0; i < 32; i++) {
    if (strA[i] == '1') {
      ab[i]->label("1");
    } else {
      ab[i]->label("0");
    }
  }
}

static void updateB() {
  std::string strB = intToBinPlus(b);

  for (int i = 0; i < 32; i++) {
    if (strB[i] == '1') {
      bb[i]->label("1");
    } else {
      bb[i]->label("0");
    }
  }
}

static void setColor(int num) {
  for (int i = 0; i < 32; i++) {
      ab[i]->color(fl_rgb_color(230, 230, 230));
      bb[i]->color(fl_rgb_color(230, 230, 230));
      cb[i]->color(fl_rgb_color(230, 230, 230));
  }

  if (num == 4) {
    for (int i = 0; i < 32; i += 4) {
      ab[i]->color(fl_rgb_color(200, 200, 200));
      bb[i]->color(fl_rgb_color(200, 200, 200));
      cb[i]->color(fl_rgb_color(200, 200, 200));
      ab[i + 1]->color(fl_rgb_color(200, 200, 200));
      bb[i + 1]->color(fl_rgb_color(200, 200, 200));
      cb[i + 1]->color(fl_rgb_color(200, 200, 200));
    }
  }

  if (num == 8) {
    for (int i = 2; i < 32; i += 6) {
      for (int j = 0; j < 3; j++){
        if (i + j == 32) break;
        ab[i + j]->color(fl_rgb_color(200, 200, 200));
        bb[i + j]->color(fl_rgb_color(200, 200, 200));
        cb[i + j]->color(fl_rgb_color(200, 200, 200));
      }
    }
  }

  if (num == 16) {
    for (int i = 0; i < 32; i += 8) {
      for (int j = 0; j < 4; j++){
        ab[i + j]->color(fl_rgb_color(200, 200, 200));
        bb[i + j]->color(fl_rgb_color(200, 200, 200));
        cb[i + j]->color(fl_rgb_color(200, 200, 200));
      }
    }
  }


  for (int i = 0; i < 32; i++) {
    if (ab[i]->label() == "0") {
      ab[i]->label("1");
    } else {
      ab[i]->label("0");
    }
    if (bb[i]->label() == "0") {
      bb[i]->label("1");
    } else {
      bb[i]->label("0");
    }
    if (cb[i]->label() == "0") {
      cb[i]->label("1");
    } else {
      cb[i]->label("0");
    }

  }

  for (int i = 0; i < 32; i++) {
    if (ab[i]->label() == "0") {
      ab[i]->label("1");
    } else {
      ab[i]->label("0");
    }
    if (bb[i]->label() == "0") {
      bb[i]->label("1");
    } else {
      bb[i]->label("0");
    }
    if (cb[i]->label() == "0") {
      cb[i]->label("1");
    } else {
      cb[i]->label("0");
    }

  }
}

static void window() {
  for (int i = 0; i < 32; i++) {
    ab[i] = new Fl_Button(30 + i * 20, 30, 20, 20, "0");
    bb[i] = new Fl_Button(30 + i * 20, 80, 20, 20, "0");
    cb[i] = new Fl_Button(30 + i * 20, 130, 20, 20, "0");
    ab[i]->callback((Fl_Callback *)cb_button);
    bb[i]->callback((Fl_Callback *)cb_button);
    cb[i]->callback((Fl_Callback *)cb_button);
  }
}

static std::string sym(std::string str, std::string symbols) {
  std::string result;
  for (int i = 0; i < str.length(); i++)
  {
      if (symbols.find(str[i]) != std::string::npos)
      {
          result += str[i];
      }
  }
  return result;
}

Fl_Spinner *n=(Fl_Spinner *)0;

static void cb_n(Fl_Spinner*, void*) {
  if (n->value() == 7) {
    n->value(4);
  } else if (n->value() == 9) {
    n->value(8);
  } else if (n->value() == 13) {
    n->value(10);
  } else if (n->value() == 15) {
    n->value(16);
  } else if (n->value() == 21) {
    n->value(2);
  } else if (n->value() == 11) {
    n->value(10);
  } else if (n->value() == 5) {
    n->value(8);
  } else if (n->value() == 3) {
    n->value(4);
  } else if (n->value() == 22) {
    n->value(16);
  } else if (n->value() == -1) {
    n->value(2);
  }


  if (n->value() == 10) {
    outputA->value(intToDec(a % pow(bits->value())).c_str());
    outputB->value(intToDec(b % pow(bits->value())).c_str());
    outputC->value(intToDec(c % pow(bits->value())).c_str());
  } else if (n->value() == 2) {
    outputA->value(intToBin(a % pow(bits->value())).c_str());
    outputB->value(intToBin(b % pow(bits->value())).c_str());
    outputC->value(intToBin(c % pow(bits->value())).c_str());
  } else if (n->value() == 16) {
    outputA->value(intToHex(a % pow(bits->value())).c_str());
    outputB->value(intToHex(b % pow(bits->value())).c_str());
    outputC->value(intToHex(c % pow(bits->value())).c_str());
  } else if (n->value() == 8) {
    outputA->value(intToOct(a % pow(bits->value())).c_str());
    outputB->value(intToOct(b % pow(bits->value())).c_str());
    outputC->value(intToOct(c % pow(bits->value())).c_str());
  } else if (n->value() == 4) {
    outputA->value(intToQuat(a % pow(bits->value())).c_str());
    outputB->value(intToQuat(b % pow(bits->value())).c_str());
    outputC->value(intToQuat(c % pow(bits->value())).c_str());
  }

  setColor(n->value());
}

Fl_Spinner *bits=(Fl_Spinner *)0;

static void cb_bits(Fl_Spinner*, void*) {
  if (n->value() == 10) {
    outputA->value(intToDec(a % pow(bits->value())).c_str());
    outputB->value(intToDec(b % pow(bits->value())).c_str());
    outputC->value(intToDec(c % pow(bits->value())).c_str());
  } else if (n->value() == 2) {
    outputA->value(intToBin(a % pow(bits->value())).c_str());
    outputB->value(intToBin(b % pow(bits->value())).c_str());
    outputC->value(intToBin(c % pow(bits->value())).c_str());
  } else if (n->value() == 16) {
    outputA->value(intToHex(a % pow(bits->value())).c_str());
    outputB->value(intToHex(b % pow(bits->value())).c_str());
    outputC->value(intToHex(c % pow(bits->value())).c_str());
  } else if (n->value() == 8) {
    outputA->value(intToOct(a % pow(bits->value())).c_str());
    outputB->value(intToOct(b % pow(bits->value())).c_str());
    outputC->value(intToOct(c % pow(bits->value())).c_str());
  } else if (n->value() == 4) {
    outputA->value(intToQuat(a % pow(bits->value())).c_str());
    outputB->value(intToQuat(b % pow(bits->value())).c_str());
    outputC->value(intToQuat(c % pow(bits->value())).c_str());
  }

  for (int i = 0; i < 32 - bits->value(); i++) {
    ab[i]->hide();
    bb[i]->hide();
    cb[i]->hide();
  }

  for (int i = 32 - bits->value(); i < 32; i++) {
    ab[i]->show();
    bb[i]->show();
    cb[i]->show();
  }
}

Fl_Input *outputA=(Fl_Input *)0;

static void cb_outputA(Fl_Input*, void*) {
  try {
    if (n->value() == 10) {
      outputA->value(sym(outputA->value(), "0123456789").c_str());
      a = std::stoi(outputA->value());
    } else if (n->value() == 16) {
      outputA->value(sym(outputA->value(), "0123456789abcdefABCDEF").c_str());
      a = hexToInt(outputA->value());
    } else if (n->value() == 8) {
      outputA->value(sym(outputA->value(), "01234567").c_str());
      a = octToInt(outputA->value());
    } else if (n->value() == 2) {
      outputA->value(sym(outputA->value(), "01").c_str());
      a = binToInt(outputA->value());
    } else if (n->value() == 4) {
      outputA->value(sym(outputA->value(), "0123").c_str());
      a = quatToInt(outputA->value());
    }
  }
  catch(...) {
    a = 0;
  }
  c = 0;
  outputC->value(0);
  updateA();
}

Fl_Input *outputB=(Fl_Input *)0;

static void cb_outputB(Fl_Input*, void*) {
  try {
    if (n->value() == 10) {
      outputB->value(sym(outputB->value(), "0123456789").c_str());
      b = std::stoi(outputB->value());
    } else if (n->value() == 16) {
      outputB->value(sym(outputB->value(), "0123456789ABCDEFabcdef").c_str());
      b = hexToInt(outputB->value());
    } else if (n->value() == 8) {
      outputB->value(sym(outputB->value(), "01234567").c_str());
      b = octToInt(outputB->value());
    } else if (n->value() == 2) {
      outputB->value(sym(outputB->value(), "01").c_str());
      b = binToInt(outputB->value());
    } else if (n->value() == 4) {
      outputB->value(sym(outputB->value(), "0123").c_str());
      b = quatToInt(outputB->value());
    }
  }
  catch(...) {
    b = 0;
  }
  c = 0;
  outputC->value(0);
  updateB();
}

Fl_Input *outputC=(Fl_Input *)0;

static void cb_outputC(Fl_Input*, void*) {
  outputC->value(sym(outputC->value(), "~").c_str());
}

static void cb_(Fl_Button*, void*) {
  c = a + b;
  resultOutput();
}

static void cb_1(Fl_Button*, void*) {
  c = a - b;
  resultOutput();
}

static void cb_2(Fl_Button*, void*) {
  c = a * b;
  resultOutput();
}

static void cb_3(Fl_Button*, void*) {
  if (b != 0) {
    c = a / b;
  }
  resultOutput();
}

static void cb_4(Fl_Button*, void*) {
  c = a % b;
  resultOutput();
}

static void cb_5(Fl_Button*, void*) {
  c = a << b;
  resultOutput();
}

static void cb_6(Fl_Button*, void*) {
  c = a >> b;
  resultOutput();
}

static void cb_A(Fl_Button*, void*) {
  c = -a;
  resultOutput();
}

static void cb_B(Fl_Button*, void*) {
  c = -b;
  resultOutput();
}

static void cb_7(Fl_Button*, void*) {
  c = a & b;
  resultOutput();
}

static void cb_8(Fl_Button*, void*) {
  c = a | b;
  resultOutput();
}

static void cb_9(Fl_Button*, void*) {
  c = a ^ b;
  resultOutput();
}

int main(int argc, char **argv) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(708, 303, "Mazur\'s Calculator");
    w = o; (void)w;
    { n = new Fl_Spinner(145, 1, 40, 24, "\320\241\320\270\321\201\321\202\320\265\320\274\320\260 \321\201\321\207\
\320\270\321\201\320\273\320\265\320\275\320\270\321\217:");
      n->minimum(-1);
      n->maximum(22);
      n->step(5);
      n->value(10);
      n->callback((Fl_Callback*)cb_n);
    } // Fl_Spinner* n
    { bits = new Fl_Spinner(290, 1, 40, 24, "\320\240\320\260\320\267\321\200\321\217\320\264\320\275\320\276\321\201\321\
\202\321\214:");
      bits->minimum(8);
      bits->maximum(32);
      bits->step(8);
      bits->value(32);
      bits->callback((Fl_Callback*)cb_bits);
    } // Fl_Spinner* bits
    { outputA = new Fl_Input(30, 200, 200, 30, "A:");
      outputA->callback((Fl_Callback*)cb_outputA);
      outputA->when(FL_WHEN_CHANGED);
    } // Fl_Input* outputA
    { outputB = new Fl_Input(255, 200, 200, 30, "B:");
      outputB->callback((Fl_Callback*)cb_outputB);
      outputB->when(FL_WHEN_CHANGED);
    } // Fl_Input* outputB
    { outputC = new Fl_Input(485, 200, 200, 30, "C:");
      outputC->callback((Fl_Callback*)cb_outputC);
      outputC->when(FL_WHEN_CHANGED);
    } // Fl_Input* outputC
    { new Fl_Box(0, 30, 30, 17, "A");
    } // Fl_Box* o
    { new Fl_Box(0, 80, 30, 16, "B");
    } // Fl_Box* o
    { new Fl_Box(0, 130, 30, 16, "C");
    } // Fl_Box* o
    { Fl_Button* o = new Fl_Button(15, 255, 50, 30, "+");
      o->callback((Fl_Callback*)cb_);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(70, 255, 50, 30, "-");
      o->callback((Fl_Callback*)cb_1);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(125, 255, 50, 30, "*");
      o->callback((Fl_Callback*)cb_2);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(180, 255, 50, 30, "/");
      o->callback((Fl_Callback*)cb_3);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(235, 255, 50, 30, "%");
      o->callback((Fl_Callback*)cb_4);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(290, 255, 50, 30, "<<");
      o->callback((Fl_Callback*)cb_5);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(345, 255, 50, 30, ">>");
      o->callback((Fl_Callback*)cb_6);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(400, 255, 50, 30, "-A");
      o->callback((Fl_Callback*)cb_A);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(455, 255, 50, 30, "-B");
      o->callback((Fl_Callback*)cb_B);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(510, 255, 50, 30, "&");
      o->callback((Fl_Callback*)cb_7);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(565, 255, 50, 30, "|");
      o->callback((Fl_Callback*)cb_8);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(620, 255, 50, 30, "^");
      o->callback((Fl_Callback*)cb_9);
    } // Fl_Button* o
    window();
    o->end();
  } // Fl_Double_Window* o
  w->show(argc, argv);
  return Fl::run();
}
